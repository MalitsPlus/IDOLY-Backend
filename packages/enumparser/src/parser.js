const parser = // Generated by Peggy 1.2.0.
  //
  // https://peggyjs.org/
  (function () {
    'use strict'

    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child
      }
      C.prototype = parent.prototype
      child.prototype = new C()
    }

    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message)
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype)
      }
      self.expected = expected
      self.found = found
      self.location = location
      self.name = 'SyntaxError'
      return self
    }

    peg$subclass(peg$SyntaxError, Error)

    function peg$padEnd(str, targetLength, padString) {
      padString = padString || ' '
      if (str.length > targetLength) {
        return str
      }
      targetLength -= str.length
      padString += padString.repeat(targetLength)
      return str + padString.slice(0, targetLength)
    }

    peg$SyntaxError.prototype.format = function (sources) {
      var str = 'Error: ' + this.message
      if (this.location) {
        var src = null
        var k
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g)
            break
          }
        }
        var s = this.location.start
        var loc = this.location.source + ':' + s.line + ':' + s.column
        if (src) {
          var e = this.location.end
          var filler = peg$padEnd('', s.line.toString().length, ' ')
          var line = src[s.line - 1]
          var last = s.line === e.line ? e.column : line.length + 1
          str +=
            '\n --> ' +
            loc +
            '\n' +
            filler +
            ' |\n' +
            s.line +
            ' | ' +
            line +
            '\n' +
            filler +
            ' | ' +
            peg$padEnd('', s.column - 1, ' ') +
            peg$padEnd('', last - s.column, '^')
        } else {
          str += '\n at ' + loc
        }
      }
      return str
    }

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return '"' + literalEscape(expectation.text) + '"'
        },

        class: function (expectation) {
          var escapedParts = expectation.parts.map(function (part) {
            return Array.isArray(part)
              ? classEscape(part[0]) + '-' + classEscape(part[1])
              : classEscape(part)
          })

          return '[' + (expectation.inverted ? '^' : '') + escapedParts + ']'
        },

        any: function () {
          return 'any character'
        },

        end: function () {
          return 'end of input'
        },

        other: function (expectation) {
          return expectation.description
        },
      }

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase()
      }

      function literalEscape(s) {
        return s
          .replace(/\\/g, '\\\\')
          .replace(/"/g, '\\"')
          .replace(/\0/g, '\\0')
          .replace(/\t/g, '\\t')
          .replace(/\n/g, '\\n')
          .replace(/\r/g, '\\r')
          .replace(/[\x00-\x0F]/g, function (ch) {
            return '\\x0' + hex(ch)
          })
          .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
            return '\\x' + hex(ch)
          })
      }

      function classEscape(s) {
        return s
          .replace(/\\/g, '\\\\')
          .replace(/\]/g, '\\]')
          .replace(/\^/g, '\\^')
          .replace(/-/g, '\\-')
          .replace(/\0/g, '\\0')
          .replace(/\t/g, '\\t')
          .replace(/\n/g, '\\n')
          .replace(/\r/g, '\\r')
          .replace(/[\x00-\x0F]/g, function (ch) {
            return '\\x0' + hex(ch)
          })
          .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
            return '\\x' + hex(ch)
          })
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation)
      }

      function describeExpected(expected) {
        var descriptions = expected.map(describeExpectation)
        var i, j

        descriptions.sort()

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i]
              j++
            }
          }
          descriptions.length = j
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0]

          case 2:
            return descriptions[0] + ' or ' + descriptions[1]

          default:
            return (
              descriptions.slice(0, -1).join(', ') +
              ', or ' +
              descriptions[descriptions.length - 1]
            )
        }
      }

      function describeFound(found) {
        return found ? '"' + literalEscape(found) + '"' : 'end of input'
      }

      return (
        'Expected ' +
        describeExpected(expected) +
        ' but ' +
        describeFound(found) +
        ' found.'
      )
    }

    function peg$parse(input, options) {
      options = options !== undefined ? options : {}

      var peg$FAILED = {}
      var peg$source = options.grammarSource

      var peg$startRuleFunctions = { File: peg$parseFile }
      var peg$startRuleFunction = peg$parseFile

      var peg$c0 = 'using'
      var peg$c1 = ';'
      var peg$c2 = 'namespace'
      var peg$c3 = '{'
      var peg$c4 = '}'
      var peg$c5 = '[ProtoContract]'
      var peg$c6 = 'public'
      var peg$c7 = 'enum'
      var peg$c8 = '[ProtoMember('
      var peg$c9 = ')]'
      var peg$c10 = ','

      var peg$r0 = /^[ \t\r\n]/
      var peg$r1 = /^[0-9]/
      var peg$r2 = /^[A-Za-z.]/
      var peg$r3 = /^[a-zA-z0-9]/

      var peg$e0 = peg$literalExpectation('using', false)
      var peg$e1 = peg$literalExpectation(';', false)
      var peg$e2 = peg$literalExpectation('namespace', false)
      var peg$e3 = peg$literalExpectation('{', false)
      var peg$e4 = peg$literalExpectation('}', false)
      var peg$e5 = peg$literalExpectation('[ProtoContract]', false)
      var peg$e6 = peg$otherExpectation('whitespace')
      var peg$e7 = peg$classExpectation([' ', '\t', '\r', '\n'], false, false)
      var peg$e8 = peg$classExpectation([['0', '9']], false, false)
      var peg$e9 = peg$classExpectation(
        [['A', 'Z'], ['a', 'z'], '.'],
        false,
        false
      )
      var peg$e10 = peg$classExpectation(
        [
          ['a', 'z'],
          ['A', 'z'],
          ['0', '9'],
        ],
        false,
        false
      )
      var peg$e11 = peg$literalExpectation('public', false)
      var peg$e12 = peg$literalExpectation('enum', false)
      var peg$e13 = peg$literalExpectation('[ProtoMember(', false)
      var peg$e14 = peg$literalExpectation(')]', false)
      var peg$e15 = peg$literalExpectation(',', false)

      var peg$f0 = function (ns) {
        return ns
      }
      var peg$f1 = function (enums) {
        return enums
      }
      var peg$f2 = function (head, values) {
        return { name: head.name, values }
      }
      var peg$f3 = function (line) {
        return line
      }
      var peg$f4 = function () {
        return parseInt(text(), 10)
      }
      var peg$f5 = function (l) {
        return l.join('')
      }
      var peg$f6 = function (name) {
        return { name }
      }
      var peg$f7 = function (id, name) {
        return { id, name }
      }

      var peg$currPos = 0
      var peg$savedPos = 0
      var peg$posDetailsCache = [{ line: 1, column: 1 }]
      var peg$maxFailPos = 0
      var peg$maxFailExpected = []
      var peg$silentFails = 0

      var peg$result

      if ('startRule' in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(
            'Can\'t start parsing from rule "' + options.startRule + '".'
          )
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule]
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos)
      }

      function offset() {
        return peg$savedPos
      }

      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos,
        }
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos)
      }

      function expected(description, location) {
        location =
          location !== undefined
            ? location
            : peg$computeLocation(peg$savedPos, peg$currPos)

        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location
        )
      }

      function error(message, location) {
        location =
          location !== undefined
            ? location
            : peg$computeLocation(peg$savedPos, peg$currPos)

        throw peg$buildSimpleError(message, location)
      }

      function peg$literalExpectation(text, ignoreCase) {
        return { type: 'literal', text: text, ignoreCase: ignoreCase }
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: 'class',
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase,
        }
      }

      function peg$anyExpectation() {
        return { type: 'any' }
      }

      function peg$endExpectation() {
        return { type: 'end' }
      }

      function peg$otherExpectation(description) {
        return { type: 'other', description: description }
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos]
        var p

        if (details) {
          return details
        } else {
          p = pos - 1
          while (!peg$posDetailsCache[p]) {
            p--
          }

          details = peg$posDetailsCache[p]
          details = {
            line: details.line,
            column: details.column,
          }

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++
              details.column = 1
            } else {
              details.column++
            }

            p++
          }

          peg$posDetailsCache[pos] = details

          return details
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos)
        var endPosDetails = peg$computePosDetails(endPos)

        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column,
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column,
          },
        }
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos
          peg$maxFailExpected = []
        }

        peg$maxFailExpected.push(expected)
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location)
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected, found),
          expected,
          found,
          location
        )
      }

      function peg$parseFile() {
        var s0, s1, s2, s3, s4, s5

        s0 = peg$currPos
        s1 = peg$parse_()
        s2 = []
        s3 = peg$currPos
        s4 = peg$parseCSharpUsing()
        if (s4 !== peg$FAILED) {
          s5 = peg$parse_()
          s4 = [s4, s5]
          s3 = s4
        } else {
          peg$currPos = s3
          s3 = peg$FAILED
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3)
          s3 = peg$currPos
          s4 = peg$parseCSharpUsing()
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_()
            s4 = [s4, s5]
            s3 = s4
          } else {
            peg$currPos = s3
            s3 = peg$FAILED
          }
        }
        s3 = peg$parse_()
        s4 = peg$parseCSharpNamespace()
        if (s4 !== peg$FAILED) {
          s5 = peg$parse_()
          peg$savedPos = s0
          s0 = peg$f0(s4)
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }

        return s0
      }

      function peg$parseCSharpUsing() {
        var s0, s1, s2, s3, s4, s5

        s0 = peg$currPos
        if (input.substr(peg$currPos, 5) === peg$c0) {
          s1 = peg$c0
          peg$currPos += 5
        } else {
          s1 = peg$FAILED
          if (peg$silentFails === 0) {
            peg$fail(peg$e0)
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_()
          s3 = peg$parsePackagePath()
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_()
            if (input.charCodeAt(peg$currPos) === 59) {
              s5 = peg$c1
              peg$currPos++
            } else {
              s5 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e1)
              }
            }
            if (s5 !== peg$FAILED) {
              s1 = [s1, s2, s3, s4, s5]
              s0 = s1
            } else {
              peg$currPos = s0
              s0 = peg$FAILED
            }
          } else {
            peg$currPos = s0
            s0 = peg$FAILED
          }
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }

        return s0
      }

      function peg$parseCSharpNamespace() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9

        s0 = peg$currPos
        if (input.substr(peg$currPos, 9) === peg$c2) {
          s1 = peg$c2
          peg$currPos += 9
        } else {
          s1 = peg$FAILED
          if (peg$silentFails === 0) {
            peg$fail(peg$e2)
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_()
          s3 = peg$parsePackagePath()
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_()
            if (input.charCodeAt(peg$currPos) === 123) {
              s5 = peg$c3
              peg$currPos++
            } else {
              s5 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e3)
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_()
              s7 = []
              s8 = peg$parseEnum()
              while (s8 !== peg$FAILED) {
                s7.push(s8)
                s8 = peg$parseEnum()
              }
              s8 = peg$parse_()
              if (input.charCodeAt(peg$currPos) === 125) {
                s9 = peg$c4
                peg$currPos++
              } else {
                s9 = peg$FAILED
                if (peg$silentFails === 0) {
                  peg$fail(peg$e4)
                }
              }
              if (s9 !== peg$FAILED) {
                peg$savedPos = s0
                s0 = peg$f1(s7)
              } else {
                peg$currPos = s0
                s0 = peg$FAILED
              }
            } else {
              peg$currPos = s0
              s0 = peg$FAILED
            }
          } else {
            peg$currPos = s0
            s0 = peg$FAILED
          }
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }

        return s0
      }

      function peg$parseEnum() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11

        s0 = peg$currPos
        s1 = peg$parse_()
        if (input.substr(peg$currPos, 15) === peg$c5) {
          s2 = peg$c5
          peg$currPos += 15
        } else {
          s2 = peg$FAILED
          if (peg$silentFails === 0) {
            peg$fail(peg$e5)
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_()
          s4 = peg$parseEnumHeader()
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_()
            if (input.charCodeAt(peg$currPos) === 123) {
              s6 = peg$c3
              peg$currPos++
            } else {
              s6 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e3)
              }
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parse_()
              s8 = []
              s9 = peg$parseEnumItems()
              while (s9 !== peg$FAILED) {
                s8.push(s9)
                s9 = peg$parseEnumItems()
              }
              s9 = peg$parse_()
              if (input.charCodeAt(peg$currPos) === 125) {
                s10 = peg$c4
                peg$currPos++
              } else {
                s10 = peg$FAILED
                if (peg$silentFails === 0) {
                  peg$fail(peg$e4)
                }
              }
              if (s10 !== peg$FAILED) {
                s11 = peg$parse_()
                peg$savedPos = s0
                s0 = peg$f2(s4, s8)
              } else {
                peg$currPos = s0
                s0 = peg$FAILED
              }
            } else {
              peg$currPos = s0
              s0 = peg$FAILED
            }
          } else {
            peg$currPos = s0
            s0 = peg$FAILED
          }
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }

        return s0
      }

      function peg$parse_() {
        var s0, s1

        peg$silentFails++
        s0 = []
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos)
          peg$currPos++
        } else {
          s1 = peg$FAILED
          if (peg$silentFails === 0) {
            peg$fail(peg$e7)
          }
        }
        while (s1 !== peg$FAILED) {
          s0.push(s1)
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos)
            peg$currPos++
          } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
              peg$fail(peg$e7)
            }
          }
        }
        peg$silentFails--
        s1 = peg$FAILED
        if (peg$silentFails === 0) {
          peg$fail(peg$e6)
        }

        return s0
      }

      function peg$parseEnumItems() {
        var s0, s1, s2, s3

        s0 = peg$currPos
        s1 = peg$parse_()
        s2 = peg$parseEnumItemLine()
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_()
          peg$savedPos = s0
          s0 = peg$f3(s2)
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }

        return s0
      }

      function peg$parseInteger() {
        var s0, s1, s2, s3

        s0 = peg$currPos
        s1 = peg$parse_()
        s2 = []
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos)
          peg$currPos++
        } else {
          s3 = peg$FAILED
          if (peg$silentFails === 0) {
            peg$fail(peg$e8)
          }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3)
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos)
              peg$currPos++
            } else {
              s3 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e8)
              }
            }
          }
        } else {
          s2 = peg$FAILED
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0
          s0 = peg$f4()
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }

        return s0
      }

      function peg$parsePackagePath() {
        var s0, s1

        s0 = []
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos)
          peg$currPos++
        } else {
          s1 = peg$FAILED
          if (peg$silentFails === 0) {
            peg$fail(peg$e9)
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1)
            if (peg$r2.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos)
              peg$currPos++
            } else {
              s1 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e9)
              }
            }
          }
        } else {
          s0 = peg$FAILED
        }

        return s0
      }

      function peg$parseAlphaNumeric() {
        var s0

        if (peg$r3.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos)
          peg$currPos++
        } else {
          s0 = peg$FAILED
          if (peg$silentFails === 0) {
            peg$fail(peg$e10)
          }
        }

        return s0
      }

      function peg$parseIdentifer() {
        var s0, s1, s2

        s0 = peg$currPos
        s1 = []
        s2 = peg$parseAlphaNumeric()
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2)
            s2 = peg$parseAlphaNumeric()
          }
        } else {
          s1 = peg$FAILED
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0
          s1 = peg$f5(s1)
        }
        s0 = s1

        return s0
      }

      function peg$parseEnumHeader() {
        var s0, s1, s2, s3, s4, s5

        s0 = peg$currPos
        if (input.substr(peg$currPos, 6) === peg$c6) {
          s1 = peg$c6
          peg$currPos += 6
        } else {
          s1 = peg$FAILED
          if (peg$silentFails === 0) {
            peg$fail(peg$e11)
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_()
          if (input.substr(peg$currPos, 4) === peg$c7) {
            s3 = peg$c7
            peg$currPos += 4
          } else {
            s3 = peg$FAILED
            if (peg$silentFails === 0) {
              peg$fail(peg$e12)
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_()
            s5 = peg$parseIdentifer()
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0
              s0 = peg$f6(s5)
            } else {
              peg$currPos = s0
              s0 = peg$FAILED
            }
          } else {
            peg$currPos = s0
            s0 = peg$FAILED
          }
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }

        return s0
      }

      function peg$parseEnumItemLine() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8

        s0 = peg$currPos
        if (input.substr(peg$currPos, 13) === peg$c8) {
          s1 = peg$c8
          peg$currPos += 13
        } else {
          s1 = peg$FAILED
          if (peg$silentFails === 0) {
            peg$fail(peg$e13)
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_()
          s3 = peg$parseInteger()
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_()
            if (input.substr(peg$currPos, 2) === peg$c9) {
              s5 = peg$c9
              peg$currPos += 2
            } else {
              s5 = peg$FAILED
              if (peg$silentFails === 0) {
                peg$fail(peg$e14)
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_()
              s7 = peg$parseIdentifer()
              if (s7 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s8 = peg$c10
                  peg$currPos++
                } else {
                  s8 = peg$FAILED
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e15)
                  }
                }
                if (s8 !== peg$FAILED) {
                  peg$savedPos = s0
                  s0 = peg$f7(s3, s7)
                } else {
                  peg$currPos = s0
                  s0 = peg$FAILED
                }
              } else {
                peg$currPos = s0
                s0 = peg$FAILED
              }
            } else {
              peg$currPos = s0
              s0 = peg$FAILED
            }
          } else {
            peg$currPos = s0
            s0 = peg$FAILED
          }
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }

        return s0
      }

      peg$result = peg$startRuleFunction()

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation())
        }

        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length
            ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
            : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        )
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse,
    }
  })()

export default parser
